#!/usr/bin/env python

PACKAGE='balloon_filter'
import roslib;
roslib.load_manifest(PACKAGE)

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator();

params = gen.add_group("Balloon filter parameters");

params.add("z_bounds__min", double_t, 1, "balloon detection below this height will be discarded", 1.0, 0.0, 20.0);
params.add("z_bounds__max", double_t, 1, "balloon detection above this height will be discarded", 1.0, 0.0, 20.0);

params.add("meas_filt__desired_dt", double_t, 1, "desired time difference between previous measurement vector, chosen from the buffer, and the current measurement", 0.5, 0.0, 10.0);
params.add("meas_filt__loglikelihood_threshold", double_t, 1, "minimal loglikelihood of a measurement to have correct speed to be considered for choosing", -2.0, -100.0, 10.0);
params.add("meas_filt__covariance_inflation", double_t, 1, "how much to inflate the measurement covariance when choosing measurements", 100.0, 0.0, 10000.0);

params.add("max_time_since_update", double_t, 1, "after no detection is associated to the chosen balloon for this duration, it is forgotten", 2.0, 0.0, 60.0);
params.add("min_updates_to_confirm", int_t, 1, "minimal number of updates to be associated to the chosen balloon for it to be confirmed", 30, 0, 600);

dist_quality_enum = gen.enum([ 
                        gen.const("no_estimate", int_t, 0, "no distance estimate is available"),
                        gen.const("blob_size_only", int_t, 1, "distance estimate from the blob size is used"),
                        gen.const("depthmap_only", int_t, 2, "distance estimate from the depthmap is used"),
                        gen.const("both", int_t, 3, "the distance estimate from the blob size and from the depthmap correspond"),
                        ],
                        "Segmentation color")
params.add("min_dist_quality", int_t, 0, "minimal quality of the distance estimate to consider a point", 1, 0, 3, edit_method=dist_quality_enum)


ukf_params = gen.add_group("UKF parameters");

ukf_params.add("ukf__process_std__position", double_t, 1, "standard deviation of process noise of the position states", 1.0, 0.0, 20.0);
ukf_params.add("ukf__process_std__yaw", double_t, 1, "standard deviation of process noise of the yaw state", 1.0, 0.0, 20.0);
ukf_params.add("ukf__process_std__speed", double_t, 1, "standard deviation of process noise of the speed state", 1.0, 0.0, 20.0);
ukf_params.add("ukf__process_std__curvature", double_t, 1, "standard deviation of process noise of the curvature state", 1.0, 0.0, 20.0);

ukf_params.add("ukf__init_std__yaw", double_t, 1, "standard deviation of initial covariance of the yaw state", 1.0, 0.0, 20.0);
ukf_params.add("ukf__init_std__speed", double_t, 1, "standard deviation of initial covariance of the speed state", 1.0, 0.0, 20.0);
ukf_params.add("ukf__init_std__curvature", double_t, 1, "standard deviation of initial covariance of the curvature state", 1.0, 0.0, 20.0);

ukf_params.add("ukf__prediction_horizon", double_t, 1, "duration of the prediction horizont for the ball trajectory", 20.0, 0.0, 100.0);

lpf_params = gen.add_group("Intermediate lowpass filter parameters");

lpf_params.add("lpf__cutoff_freq__curvature", double_t, 1, "cutoff frequency of the intermediary filter for curvature [Hz]", 0.5, 0.0, 20.0);


exit(gen.generate(PACKAGE, "balloon_filter", "FilterParams"))
